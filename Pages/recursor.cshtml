using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.RazorPages;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Localization;
using Microsoft.Extensions.Logging;

namespace PowerDNS_Web.Pages
{
    public class RecursorModel : PageModel
    {
        private readonly IHttpClientFactory _httpClientFactory;
        private readonly ILogger<RecursorModel>
    _logger;
    private readonly IConfiguration _cfg;
    private readonly IStringLocalizer<RecursorModel>
        _L;

        private string PdnsUrl => _cfg["pdns:url"] ?? "";
        private string PdnsKey => _cfg["pdns:api_key"] ?? "";
        private string RecursorUrl => _cfg["recursor:url"] ?? "";
        private string RecursorKey => _cfg["recursor:api_key"] ?? "";
        private string RecursorEnabled => _cfg["recursor:Enabled"] ?? "Disabled";

        public List<string>
            AvailableZones { get; private set; } = new();
            public List<ForwardZoneVm>
                ForwardZones { get; private set; } = new();

                public RecursorModel(
                IHttpClientFactory httpClientFactory,
                ILogger<RecursorModel>
                    logger,
                    IConfiguration configuration,
                    IStringLocalizer<RecursorModel>
                        localizer)
                        {
                        _httpClientFactory = httpClientFactory;
                        _logger = logger;
                        _cfg = configuration;
                        _L = localizer;
                        }

                        public class ForwardZoneVm
                        {
                        public string Name { get; set; } = "";
                        public List<string>
                            ForwardTo { get; set; } = new();
                            }

                            // === DTOs for PDNS/Recursor APIs ===
                            private class AuthZoneDto
                            {
                            public string Name { get; set; } = "";
                            public string Kind { get; set; } = "";
                            }
                            private class RecursorZoneDto
                            {
                            public string Name { get; set; } = "";
                            public string Kind { get; set; } = "";
                            public List<string>
                                Servers { get; set; } = new();
                                public bool? Recursion_Desired { get; set; }
                                }

                                public async Task OnGetAsync()
                                {
                                ViewData["RecursorEnabled"] = RecursorEnabled;

                                // 1) authoritative zones (для списка "Available Zones")
                                var authZones = await SafeGetAuthZonesAsync();

                                // 2) recursor forward zones
                                var recForward = (RecursorEnabled == "Enabled")
                                ? await SafeGetRecursorZonesAsync()
                                : new List<RecursorZoneDto>
                                    ();

                                    // View models
                                    ForwardZones = recForward
                                    .Where(z => string.Equals(z.Kind, "Forwarded", StringComparison.OrdinalIgnoreCase))
                                    .Select(z => new ForwardZoneVm
                                    {
                                    Name = z.Name,
                                    ForwardTo = z.Servers ?? new List<string>
                                        ()
                                        })
                                        .OrderBy(z => z.Name != "." ? 1 : 0)
                                        .ThenBy(z => z.Name)
                                        .ToList();

                                        // Available = все авторитативные зоны за вычетом уже сконфигурированных forward-зон
                                        var forwardedNames = new HashSet<string>
                                            (
                                            ForwardZones.Select(z => z.Name),
                                            StringComparer.OrdinalIgnoreCase);

                                            AvailableZones = authZones
                                            .Select(z => EnsureTrailingDot(z.Name))
                                            .Where(n => !forwardedNames.Contains(n))
                                            .OrderBy(n => n)
                                            .ToList();
                                            }

                                            // ===== Handlers =====

                                            // Add forward zone (default server 127.0.0.1:5300)
                                            public async Task<IActionResult>
                                                OnPostAddForwardZoneAsync()
                                                {
                                                try
                                                {
                                                var body = await new System.IO.StreamReader(Request.Body).ReadToEndAsync();
                                                var obj = JsonSerializer.Deserialize<Dictionary<string, string>>(body, new JsonSerializerOptions
                {
                    PropertyNameCaseInsensitive = true
                });

                var zone = obj != null && obj.TryGetValue("Zone", out var z) ? z?.Trim() : null;
                if (string.IsNullOrWhiteSpace(zone))
                    return BadRequest(new { success = false, message = _L["Err.ZoneRequired"] });

                if (RecursorEnabled != "Enabled")
                    return BadRequest(new { success = false, message = _L["Err.RecursorDisabled"] });

                var name = EnsureTrailingDot(zone);
                var payload = new
                {
                    name,
                    kind = "Forwarded",
                    servers = new[] { "127.0.0.1:5300" },
                    recursion_desired = false
                };

                using var client = NewRecursorClient();
                var content = new StringContent(JsonSerializer.Serialize(payload), Encoding.UTF8, "application/json");
                var resp = await client.PostAsync($"{RecursorUrl}/api/v1/servers/localhost/zones", content);
                var respBody = await resp.Content.ReadAsStringAsync();

                if (!resp.IsSuccessStatusCode)
                    return StatusCode((int)resp.StatusCode, new { success = false, message = _L["Err.RecursorApi", respBody] });

                return new JsonResult(new { success = true, message = _L["Ans.Forward.Added"] });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "AddForwardZone failed");
                return StatusCode(500, new { success = false, message = _L["Err.Internal"] });
            }
        }

        // Remove forward zone
        public async Task<IActionResult> OnPostRemoveForwardZoneAsync()
        {
            try
            {
                var body = await new System.IO.StreamReader(Request.Body).ReadToEndAsync();
                var obj = JsonSerializer.Deserialize<Dictionary<string, string>>(body, new JsonSerializerOptions
                {
                    PropertyNameCaseInsensitive = true
                });

                var zone = obj != null && obj.TryGetValue("Zone", out var z) ? z?.Trim() : null;
                if (string.IsNullOrWhiteSpace(zone))
                    return BadRequest(new { success = false, message = _L["Err.ZoneRequired"] });

                var name = EnsureTrailingDot(zone);
                if (name == ".")
                    return BadRequest(new { success = false, message = _L["Err.CannotDeleteRoot"] });

                if (RecursorEnabled != "Enabled")
                    return BadRequest(new { success = false, message = _L["Err.RecursorDisabled"] });

                using var client = NewRecursorClient();
                var resp = await client.DeleteAsync($"{RecursorUrl}/api/v1/servers/localhost/zones/{name}");
                var respBody = await resp.Content.ReadAsStringAsync();

                if (!resp.IsSuccessStatusCode)
                    return StatusCode((int)resp.StatusCode, new { success = false, message = _L["Err.RecursorApi", respBody] });

                return new JsonResult(new { success = true, message = _L["Ans.Forward.Removed"] });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "RemoveForwardZone failed");
                return StatusCode(500, new { success = false, message = _L["Err.Internal"] });
            }
        }

        // Edit forwarders list for zone
        public async Task<IActionResult> OnPostEditZoneAsync()
        {
            try
            {
                var body = await new System.IO.StreamReader(Request.Body).ReadToEndAsync();
                var obj = JsonSerializer.Deserialize<Dictionary<string, string>>(body, new JsonSerializerOptions
                {
                    PropertyNameCaseInsensitive = true
                });

                var nameRaw = obj != null && obj.TryGetValue("Name", out var n) ? n?.Trim() : null;
                var dnsCsv = obj != null && obj.TryGetValue("DnsServers", out var s) ? s : null;

                if (string.IsNullOrWhiteSpace(nameRaw))
                    return BadRequest(new { success = false, message = _L["Err.ZoneRequired"] });

                var servers = (dnsCsv ?? "")
                    .Split(',', StringSplitOptions.RemoveEmptyEntries)
                    .Select(x => x.Trim())
                    .Where(x => !string.IsNullOrWhiteSpace(x))
                    .Distinct(StringComparer.OrdinalIgnoreCase)
                    .ToList();

                if (servers.Count == 0)
                    return BadRequest(new { success = false, message = _L["Err.NoServersProvided"] });

                // (минимальная валидация "IP:port")
                foreach (var sv in servers)
                {
                    if (!LooksLikeHostPort(sv))
                        return BadRequest(new { success = false, message = _L["Err.InvalidServerFormat", sv] });
                }

                if (RecursorEnabled != "Enabled")
                    return BadRequest(new { success = false, message = _L["Err.RecursorDisabled"] });

                var name = EnsureTrailingDot(nameRaw);

                var payload = new
                {
                    name,
                    kind = "Forwarded",
                    servers,
                    recursion_desired = false
                };

                using var client = NewRecursorClient();
                var content = new StringContent(JsonSerializer.Serialize(payload), Encoding.UTF8, "application/json");
                // PUT на конкретную зону
                var resp = await client.PutAsync($"{RecursorUrl}/api/v1/servers/localhost/zones/{name}", content);
                var respBody = await resp.Content.ReadAsStringAsync();

                if (!resp.IsSuccessStatusCode)
                    return StatusCode((int)resp.StatusCode, new { success = false, message = _L["Err.RecursorApi", respBody] });

                return new JsonResult(new { success = true, message = _L["Ans.Forward.Updated"] });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "EditZone (forwarders) failed");
                return StatusCode(500, new { success = false, message = _L["Err.Internal"] });
            }
        }

        // ===== helpers =====
        private async Task<List<AuthZoneDto>> SafeGetAuthZonesAsync()
        {
            try
            {
                using var client = _httpClientFactory.CreateClient();
                client.DefaultRequestHeaders.Remove("X-API-Key");
                client.DefaultRequestHeaders.Add("X-API-Key", PdnsKey);

                var resp = await client.GetAsync($"{PdnsUrl}/api/v1/servers/localhost/zones");
                if (!resp.IsSuccessStatusCode) return new List<AuthZoneDto>();

                var json = await resp.Content.ReadAsStringAsync();
                var all = JsonSerializer.Deserialize<List<AuthZoneDto>>(json, new JsonSerializerOptions
                {
                    PropertyNameCaseInsensitive = true
                }) ?? new();

                return all;
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Failed to get authoritative zones");
                return new List<AuthZoneDto>();
            }
        }

        private async Task<List<RecursorZoneDto>> SafeGetRecursorZonesAsync()
        {
            var list = new List<RecursorZoneDto>();
            try
            {
                using var client = NewRecursorClient();
                var resp = await client.GetAsync($"{RecursorUrl}/api/v1/servers/localhost/zones");
                if (!resp.IsSuccessStatusCode) return list;

                var json = await resp.Content.ReadAsStringAsync();
                list = JsonSerializer.Deserialize<List<RecursorZoneDto>>(json, new JsonSerializerOptions
                {
                    PropertyNameCaseInsensitive = true
                }) ?? new();
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Failed to get recursor zones");
            }
            return list;
        }

        private HttpClient NewRecursorClient()
        {
            var c = _httpClientFactory.CreateClient();
            c.DefaultRequestHeaders.Remove("X-API-Key");
            c.DefaultRequestHeaders.Add("X-API-Key", RecursorKey);
            return c;
        }

        private static string EnsureTrailingDot(string s)
            => string.IsNullOrWhiteSpace(s) ? s : (s.EndsWith('.') ? s : s + ".");

        private static bool LooksLikeHostPort(string s)
        {
            // допускаем IPv4:port или hostname:port (очень грубо)
            var idx = s.LastIndexOf(':');
            if (idx <= 0 || idx >= s.Length - 1) return false;
            var portStr = s[(idx + 1)..];
            if (!int.TryParse(portStr, out var port) || port < 1 || port > 65535) return false;
            // host часть не пустая
            return !string.IsNullOrWhiteSpace(s[..idx]);
        }
    }
}
